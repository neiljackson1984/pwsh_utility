#!pwsh

function Get-PathOfFirefoxProfileDirectory {
    <#
        .SYNOPSIS
        returns the path of the most-recently-written firefox profile
        directory (which, if you have (a singlke instance of) firefox
        running and are using it interactively, is likely to be the
        directory of the firefox profile that Firefox currently has loaded.
    #>
    return $(
        Get-ChildItem -force -directory (join-path $env:appdata "Mozilla/Firefox/Profiles") | 
        sort LastWriteTime | 
        select -last 1 
    )
}

function Get-WebRequestSessionWithFirefoxCookies {
    <#
    .SYNOPSIS
    Creates and returns a new
    Microsoft.PowerShell.Commands.WebRequestSession object (suitable to be
    passed as the WebSession parameter to Invoke-WebRequest) loaded with all
    of the cookies from the Firefox profile whose directory is given as an
    aragument.

    This function causes no movement of information into the Firefox profile
    -- only out of it.

    The bulk of this code was generated by ChatGPT, and then manually fixed
    up by me.

    .EXAMPLE
    ##
    ```
    $webRequestSession = Get-WebRequestSessionWithFirefoxCookies (Get-PathOfFirefoxProfileDirectory)

    Invoke-WebRequest -WebSession $webRequestSession -Uri "https://example.com/foo"
    ```

    .EXAMPLE
    ##
    ```
    $webRequestSession = Get-WebRequestSessionWithFirefoxCookies

    Invoke-WebRequest -WebSession $webRequestSession -Uri "https://example.com/foo"
    ```

    .EXAMPLE
    ##
    ```
    Invoke-WebRequest -WebSession (Get-WebRequestSessionWithFirefoxCookies) -Uri "https://example.com/foo"
    ```




    #>
    param (
        [string] $PathOfFirefoxProfileDirectory = $null
    )

    if(-not $PathOfFirefoxProfileDirectory){
        $PathOfFirefoxProfileDirectory = Get-PathOfFirefoxProfileDirectory
    }

    # Define the path to the cookies.sqlite file within the Firefox profile folder
    $pathOfFirefoxCookiesDatabaseFile = Join-Path -Path $PathOfFirefoxProfileDirectory -ChildPath "cookies.sqlite"

    # Load the SQLite assembly 
    .{
        # this is fast-and-dirty way to manage the dependency -- install it
        # fresh as needed in a (hopefully) uniquely named directory.  We use
        # the SAME(hopefully-unique-named directory as a way top avoid
        # having to redownload the dependency upon every run.
        $globallyUniqueNameOfPackagesDirectory = "0d9099a3b7ac4035861dfa79b2c73022"
        $pathOfPackagesDirectory = (join-path (join-path $env:temp $globallyUniqueNameOfPackagesDirectory) "packages")
        ## nuget install System.Data.SQLite -OutputDirectory $pathOfPackagesDirectory | write-host
        New-Item -itemtype directory -force -path $pathOfPackagesDirectory | out-null
        nuget install System.Data.SQLite -OutputDirectory $pathOfPackagesDirectory -Source "https://api.nuget.org/v3/index.json" -Verbosity detailed | write-information

    }
        
    # Load the SQLite assembly
    $pathOfSqliteDllFile = $(gci -file -recurse -force $pathOfPackagesDirectory -filter "System.Data.SQLite.dll" | sort FullName | select -last 1)

    $null = [System.Reflection.Assembly]::LoadFrom($pathOfSqliteDllFile)

    @{
        
        TypeDefinition = (@(
            'using System;'
            'using System.Data;'
            'using System.Data.SQLite;'
            ''
            'public class SQLiteHelper {'
            '    public static DataTable ExecuteQuery(string dbPath, string query) {'
            '        using (var connection = new SQLiteConnection($"Data Source={dbPath};Version=3;")) {'
            '            connection.Open();'
            '            using (var command = new SQLiteCommand(query, connection)) {'
            '                using (var reader = command.ExecuteReader()) {'
            '                    var dataTable = new DataTable();'
            '                    dataTable.Load(reader);'
            '                    return dataTable;'
            '                }'
            '            }'
            '        }'
            '    }'
            '}'
        ) -join "`n")

        ReferencedAssemblies = @(
            $pathOfSqliteDllFile

            # I found the below assembly names by repeatedly attempting to run
            # the Add-Type command without the below items and then looking at
            # the compiler error messages, which recommended the names of
            # assemblies to install. This is probably not a stable or
            # sustainable way to ensure the compile has the dependencies it
            # needs.

            'System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
            'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
            'System.Data.Common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'
            'System.ComponentModel.Primitives, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'
            'System.ComponentModel.TypeConverter, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'
        )
    } |% { Add-Type @_ } 

    # Query to get cookies from the SQLite database
    $query = "SELECT host, name, value, path, expiry, isSecure FROM moz_cookies"

    # Execute the query and get the cookies
    $cookiesTable = [SQLiteHelper]::ExecuteQuery($pathOfFirefoxCookiesDatabaseFile, $query)

    # see [# https://learn.microsoft.com/en-us/dotnet/api/microsoft.powershell.commands.webrequestsession?view=powershellsdk-7.4.0]

    # Create a WebRequestSession object
    $webRequestSession = New-Object Microsoft.PowerShell.Commands.WebRequestSession

    # Import the cookies into the WebRequestSession
    foreach ($row in $cookiesTable.Rows) {
        try{
            $cookie         = New-Object System.Net.Cookie
            $cookie.Name    = $row["name"]
            $cookie.Value   = $row["value"]
            $cookie.Domain  = $row["host"]
            $cookie.Path    = $row["path"]
            $cookie.Secure  = [bool]$row["isSecure"]
            $cookie.Expires = [datetime]::FromFileTimeUtc(10000000 * [long]$row["expiry"] + 116444736000000000)
            $webRequestSession.Cookies.Add($cookie)
            write-information "succesfully imported a cookie"
        } catch {
            write-warning "encountered exception when trying to import a cookie: $($_)"
        }
    }

    # Return the WebRequestSession object
    return $webRequestSession
}


